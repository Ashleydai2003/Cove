// /Backend/prisma/schema.prisma
// This file contains the Prisma schema, learn more about it in the docs: https://pris.ly/d/prisma-schema

// Configure the Prisma Client generator
generator client {
  provider = "prisma-client-js"
  // Generate TypeScript types
  previewFeatures = []
  output = "../node_modules/.prisma/client"
  binaryTargets = ["native", "rhel-openssl-1.0.x"]
}

// Configure the database connection
datasource db {
  provider = "postgresql"
  // The connection URL will be provided via environment variable
  url = env("DATABASE_URL")
}

// Prisma Enum for RSVPs 
enum RSVPStatus {
  GOING
  MAYBE
  NOT_GOING
}

enum MemberRole {
  MEMBER
  ADMIN
}

// User model with Firebase authentication
// authentication, verification, app status
model User {
  id              String      @id // Using Firebase UID as ID
  name            String?
  phone           String      @unique
  onboarding      Boolean     @default(true)
  verified        Boolean     @default(false)  // IMPORTANT: in MVP, only verified users can create Coves
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  // Relations
  profile         UserProfile?
  profilePhotoID  String?     @unique
  profilePhoto    UserImage?  @relation("ProfilePhoto", fields: [profilePhotoID], references: [id])
  photos          UserImage[] @relation("UserPhotos")
  createdCoves    Cove[]      @relation("CreatedCoves")
  coveMemberships CoveMember[]
  createdEvents   Event[]     @relation("CreatedEvents")
  eventRSVPs      EventRSVP[]

  // Friendship relations
  friendships1   Friendship[] @relation("FriendshipUser1")
  friendships2   Friendship[] @relation("FriendshipUser2")

  // Friend requests sent and received
  sentFriendRequests     FriendRequest[] @relation("SentRequests")
  receivedFriendRequests FriendRequest[] @relation("ReceivedRequests")
} 

// UserProfile Model
// Optional, user-controlled, descriptive
model UserProfile {
  id             String   @id @default(cuid())
  user           User     @relation(fields: [userId], references: [id])
  userId         String   @unique
  age            Int?
  birthdate       DateTime? 
  interests      String[]
  latitude       Float?
  longitude      Float?
  almaMater      String?
  job            String?
  workLocation   String?
  relationStatus String?
  sexuality      String?
  bio            String?
  gender         String? 
}

model Friendship {
  id        String   @id @default(cuid())
  user1Id   String
  user2Id   String
  createdAt DateTime @default(now())

  user1     User     @relation("FriendshipUser1", fields: [user1Id], references: [id])
  user2     User     @relation("FriendshipUser2", fields: [user2Id], references: [id])

  @@unique([user1Id, user2Id])
  @@index([user2Id, user1Id]) // For reverse lookups
}

model FriendRequest {
  id         String   @id @default(cuid())
  fromUserId String
  toUserId   String
  createdAt  DateTime @default(now())

  fromUser   User     @relation("SentRequests", fields: [fromUserId], references: [id])
  toUser     User     @relation("ReceivedRequests", fields: [toUserId], references: [id])

  @@unique([fromUserId, toUserId])
}

// User Image model 
// Document how to use the @relation somewhere 
model UserImage {
  id            String    @id @default(cuid())
  user          User      @relation("UserPhotos", fields: [userId], references: [id])
  userId        String
  createdAt     DateTime  @default(now())
  profileUser   User?     @relation("ProfilePhoto")
}

// Cove model for groups
model Cove {
  id          String      @id @default(cuid())
  name        String
  description String?
  location    String     // City name for now
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  creatorId   String      // ID of the user who created the cove
  createdBy   User        @relation("CreatedCoves", fields: [creatorId], references: [id])
  members     CoveMember[]
  events      Event[]
  coverPhotoID String?    @unique
  coverPhoto  CoveImage?  @relation("CoveCoverPhoto", fields: [coverPhotoID], references: [id])
}

// Cove Member model for managing member permissions
model CoveMember {
  id        String     @id @default(cuid())
  coveId    String
  userId    String
  role      MemberRole @default(MEMBER)
  joinedAt  DateTime   @default(now())
  cove      Cove       @relation(fields: [coveId], references: [id])
  user      User       @relation(fields: [userId], references: [id])

  @@unique([coveId, userId])
}

// Event model for cove events
model Event {
  id          String      @id @default(cuid())
  name        String
  description String?
  date        DateTime
  location    String
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  coveId      String
  cove        Cove        @relation(fields: [coveId], references: [id])
  hostId      String      // ID of the user who is hosting the event
  hostedBy    User        @relation("CreatedEvents", fields: [hostId], references: [id])
  rsvps       EventRSVP[]
  coverPhotoID String?    @unique
  coverPhoto  EventImage? @relation("EventCoverPhoto", fields: [coverPhotoID], references: [id])
}

// TODO: Change RSVP model to only have GOING and MAYBE 
// Event RSVP model for tracking attendees
model EventRSVP {
  id        String   @id @default(cuid())
  eventId   String
  userId    String
  status    RSVPStatus   @default(GOING) // Can be "GOING", "MAYBE", "NOT_GOING"
  createdAt DateTime @default(now())
  event     Event    @relation(fields: [eventId], references: [id])
  user      User     @relation(fields: [userId], references: [id])

  @@unique([eventId, userId])
}

// Cove Image model for storing cove photos
model CoveImage {
  id            String    @id @default(cuid())
  coveId        String
  createdAt     DateTime  @default(now())
  coverCove     Cove?     @relation("CoveCoverPhoto")
}

// Event Image model for storing event photos
model EventImage {
  id            String    @id @default(cuid())
  eventId       String
  createdAt     DateTime  @default(now())
  coverEvent    Event?    @relation("EventCoverPhoto")
}

// Admin allowlist model (modifiable by super admin)
model AdminPhoneAllowlist {
  id          String    @id @default(cuid())
  phoneNumber String    @unique
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  addedBy     String    // ID of the super admin who added this number
  isActive    Boolean   @default(false) // Indicates whether this admin has completed their signup process
  cove        String?

  @@map("admin_phone_allowlist")
}